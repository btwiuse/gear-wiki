"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[4655],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=a,f=d["".concat(u,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9104:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_label:"gFT (ERC-20)",sidebar_position:3},i="Gear Fungible Token",s={unversionedId:"examples/gft-20",id:"examples/gft-20",title:"Gear Fungible Token",description:"What is ERC-20?",source:"@site/docs/examples/gft-20.md",sourceDirName:"examples",slug:"/examples/gft-20",permalink:"/docs/examples/gft-20",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/examples/gft-20.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"gFT (ERC-20)",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"PING-PONG",permalink:"/docs/examples/ping"},next:{title:"gNFT (ERC-721)",permalink:"/docs/examples/gnft-721"}},u={},l=[{value:"What is ERC-20?",id:"what-is-erc-20",level:2},{value:"Storage Structure",id:"storage-structure",level:2},{value:"<code>Action</code> and <code>Event</code>",id:"action-and-event",level:3},{value:"Message/Reply structures used in <code>Action</code> and <code>Event</code>",id:"messagereply-structures-used-in-action-and-event",level:3},{value:"gFT functions",id:"gft-functions",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:l};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"gear-fungible-token"},"Gear Fungible Token"),(0,a.kt)("h2",{id:"what-is-erc-20"},"What is ERC-20?"),(0,a.kt)("p",null,"ERC-20 is a standard that\u2019s used for creating and issuing smart contracts on the Ethereum blockchain. It was created by Ethereum developers on behalf of the Ethereum community in 2015, and it was officially recognised in 2017."),(0,a.kt)("p",null,"These smart contracts can then be used to create tokenized assets that represent anything on the Ethereum blockchain like:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"In-game currency")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Financial instruments like a share in a company")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Fiat currencies, like USD for example")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Ounces of Gold"))),(0,a.kt)("p",null,"These tokenized assets are known as fungible tokens as all instances of a given ERC-20 token are the same and they can be used interchangeably. A token that is unique and can not be interchangeable is known as a Non Fungible Token."),(0,a.kt)("p",null,"Gear provides native implementaion of fungible token (gFT) described in this article. It explains the programming interface, data structure, basic functions and explains their purpose. It can be used as is or modified to suit your own scenarios. Anyone can easily create their own application and run it on the Gear Network. The source code is available on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/fungible-token"},"GitHub"),". "),(0,a.kt)("h2",{id:"storage-structure"},"Storage Structure"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"struct FungibleToken {\n    name: String, /// Name of the token.\n    symbol: String,  /// Symbol of the token.\n    total_supply: u128, /// Total supply of the token.\n    balances: BTreeMap<ActorId, u128>, /// Map to hold balances of token holders.\n    allowances: BTreeMap<ActorId, BTreeMap<ActorId, u128>>, /// Map to hold allowance information of token holders.\n}\n")),(0,a.kt)("h3",{id:"action-and-event"},(0,a.kt)("inlineCode",{parentName:"h3"},"Action")," and ",(0,a.kt)("inlineCode",{parentName:"h3"},"Event")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Event")," is generated when ",(0,a.kt)("inlineCode",{parentName:"p"},"Action")," is triggered. ",(0,a.kt)("inlineCode",{parentName:"p"},"Action")," enum wraps various ",(0,a.kt)("inlineCode",{parentName:"p"},"Input")," structs, ",(0,a.kt)("inlineCode",{parentName:"p"},"Event")," wraps ",(0,a.kt)("inlineCode",{parentName:"p"},"Reply"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Decode, Encode, TypeInfo)]\npub enum Action {\n    Mint(u128),\n    Burn(u128),\n    Transfer {\n        from: ActorId,\n        to: ActorId,\n        amount: u128,\n    },\n    Approve {\n        to: ActorId,\n        amount: u128,\n    },\n    TotalSupply,\n    BalanceOf(ActorId),\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Encode, Decode, TypeInfo)]\npub enum Event {\n    Transfer {\n        from: ActorId,\n        to: ActorId,\n        amount: u128,\n    },\n    Approve {\n        from: ActorId,\n        to: ActorId,\n        amount: u128,\n    },\n    TotalSupply(u128),\n    Balance(u128),\n}\n")),(0,a.kt)("h3",{id:"messagereply-structures-used-in-action-and-event"},"Message/Reply structures used in ",(0,a.kt)("inlineCode",{parentName:"h3"},"Action")," and ",(0,a.kt)("inlineCode",{parentName:"h3"},"Event")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Decode, Encode, TypeInfo)]\npub struct InitConfig {\n    pub name: String,\n    pub symbol: String,\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Encode, Decode, TypeInfo)]\npub struct ApproveInput {\n    pub spender: ActorId,\n    pub amount: u128,\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Encode, Decode, TypeInfo)]\npub struct ApproveReply {\n    pub owner: ActorId,\n    pub spender: ActorId,\n    pub amount: u128,\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Decode, Encode, TypeInfo)]\npub struct TransferInput {\n    pub to: ActorId,\n    pub amount: u128,\n}\n")),(0,a.kt)("h2",{id:"gft-functions"},"gFT functions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Minting the specified `amount` of tokens for the account that called this function.\n    fn mint(&mut self, amount: u128)\n\n    /// Burning the specified `amount` of tokens for the `account` that called this function\n    fn burn(&mut self, amount: u128)\n\n    /// Transfers `amount` tokens from `sender` account to `recipient` account.\n    fn transfer(&mut self, from: &ActorId, to: &ActorId, amount: u128)\n\n    /// Adds/Updates allowance entry for `spender` account to tranfer upto `amount` from `owner` account.\n    fn approve(&mut self, to: &ActorId, amount: u128)\n\n")),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"A source code of the contract example provided by Gear is available on GitHub: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/fungible-token/blob/master/src/lib.rs"},"fungible-token/src/lib.rs"),"."),(0,a.kt)("p",null,"See also an example of the smart contract testing implementation based on ",(0,a.kt)("inlineCode",{parentName:"p"},"gtest"),": ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/fungible-token/blob/master/src/tests.rs"},"fungible-token/src/tests.rs"),"."),(0,a.kt)("p",null,"For more details about testing smart contracts written on Gear, refer to this article: ",(0,a.kt)("a",{parentName:"p",href:"/docs/developing-contracts/testing"},"Program Testing"),"."))}p.isMDXComponent=!0}}]);